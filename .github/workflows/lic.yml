name: Dependency License Analysis

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  analyze-licenses:
    runs-on: ubuntu-latest

    steps:
      # Step 1: Checkout the repository
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Set up Go
      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21' # Use the latest stable version of Go

      # Step 3: Install Gradle (for Kotlin projects)
      - name: Install Gradle
        if: contains(github.event.repository.language, 'Kotlin')
        run: |
          sudo apt-get update
          sudo apt-get install -y gradle

      # Step 4: Install Maven (for Java projects)
      - name: Install Maven
        if: contains(github.event.repository.language, 'Java')
        run: |
          sudo apt-get update
          sudo apt-get install -y maven

      # Step 5: Write the Go code to a file and run it
      - name: Run License Analysis Tool
        run: |
          cat << 'EOF' > main.go
          package main

          import (
              "bytes"
              "fmt"
              "html/template"
              "io/ioutil"
              "log"
              "os"
              "os/exec"
              "regexp"
              "strings"
          )

          // Dependency represents a project dependency with its name and license
          type Dependency struct {
              Name    string
              License string
          }

          // LicenseCheckResult represents the result of the license analysis
          type LicenseCheckResult struct {
              Dependency
              IsCopyleft bool
          }

          // CopyleftLicenses is a list of known copyleft licenses
          var CopyleftLicenses = []string{
              "GPL", "AGPL", "LGPL", "MPL", "EPL", "CDDL", "CPOL",
          }

          func main() {
              // Step 1: Check if the project is Gradle or Maven
              var dependencies []string
              var err error

              if _, err := os.Stat("build.gradle"); err == nil {
                  // Gradle project
                  dependencies, err = extractGradleDependencies("build.gradle")
              } else if _, err := os.Stat("pom.xml"); err == nil {
                  // Maven project
                  dependencies, err = extractMavenDependencies("pom.xml")
              } else {
                  log.Fatalf("No build.gradle or pom.xml file found in the current directory")
              }

              if err != nil {
                  log.Fatalf("Error extracting dependencies: %v", err)
              }

              // Step 2: Fetch licenses for each dependency
              results := make([]LicenseCheckResult, 0)
              for _, dep := range dependencies {
                  license, err := fetchLicense(dep)
                  if err != nil {
                      log.Printf("Error fetching license for %s: %v", dep, err)
                      continue
                  }

                  // Check if the license is copyleft
                  isCopyleft := isCopyleftLicense(license)
                  results = append(results, LicenseCheckResult{
                      Dependency: Dependency{
                          Name:    dep,
                          License: license,
                      },
                      IsCopyleft: isCopyleft,
                  })
              }

              // Step 3: Generate HTML report
              err = generateHTMLReport(results, "report.html")
              if err != nil {
                  log.Fatalf("Error generating HTML report: %v", err)
              }

              fmt.Println("License analysis completed. Report generated as report.html")
          }

          // extractGradleDependencies parses the build.gradle file to extract dependency names
          func extractGradleDependencies(filePath string) ([]string, error) {
              content, err := ioutil.ReadFile(filePath)
              if err != nil {
                  return nil, fmt.Errorf("failed to read build.gradle: %v", err)
              }

              // Regex to match dependencies in the format "implementation 'group:name:version'"
              re := regexp.MustCompile(`implementation\s+['"]([^'"]+)['"]`)
              matches := re.FindAllStringSubmatch(string(content), -1)

              dependencies := make([]string, 0)
              for _, match := range matches {
                  if len(match) > 1 {
                      dependencies = append(dependencies, match[1])
                  }
              }

              return dependencies, nil
          }

          // extractMavenDependencies parses the pom.xml file to extract dependency names
          func extractMavenDependencies(filePath string) ([]string, error) {
              content, err := ioutil.ReadFile(filePath)
              if err != nil {
                  return nil, fmt.Errorf("failed to read pom.xml: %v", err)
              }

              // Regex to match dependencies in the format <groupId>:<artifactId>:<version>
              re := regexp.MustCompile(`<dependency>\s*<groupId>([^<]+)</groupId>\s*<artifactId>([^<]+)</artifactId>\s*<version>([^<]+)</version>\s*</dependency>`)
              matches := re.FindAllStringSubmatch(string(content), -1)

              dependencies := make([]string, 0)
              for _, match := range matches {
                  if len(match) > 3 {
                      dependency := fmt.Sprintf("%s:%s:%s", match[1], match[2], match[3])
                      dependencies = append(dependencies, dependency)
                  }
              }

              return dependencies, nil
          }

          // fetchLicense fetches the license for a given dependency
          func fetchLicense(dependency string) (string, error) {
              // Use Maven's dependency:tree command to fetch licenses
              cmd := exec.Command("mvn", "dependency:tree", "-Dverbose")
              cmd.Dir = "." // Set the working directory to the project root
              var out bytes.Buffer
              cmd.Stdout = &out
              err := cmd.Run()
              if err != nil {
                  return "", fmt.Errorf("failed to run mvn command: %v", err)
              }

              // Parse the output to find the license for the specific dependency
              output := out.String()
              lines := strings.Split(output, "\n")
              for _, line := range lines {
                  if strings.Contains(line, dependency) && strings.Contains(line, "License:") {
                      parts := strings.Split(line, "License:")
                      if len(parts) > 1 {
                          return strings.TrimSpace(parts[1]), nil
                      }
                  }
              }

              return "Unknown", nil
          }

          // isCopyleftLicense checks if a license is copyleft
          func isCopyleftLicense(license string) bool {
              for _, copyleft := range CopyleftLicenses {
                  if strings.Contains(strings.ToUpper(license), copyleft) {
                      return true
                  }
              }
              return false
          }

          // generateHTMLReport generates an HTML report from the license analysis results
          func generateHTMLReport(results []LicenseCheckResult, outputPath string) error {
              const htmlTemplate = `
          <!DOCTYPE html>
          <html>
          <head>
              <title>Dependency License Report</title>
              <style>
                  table { width: 100%; border-collapse: collapse; }
                  th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
                  .copyleft { background-color: #ffcccc; }
                  .permissive { background-color: #ccffcc; }
              </style>
          </head>
          <body>
              <h1>Dependency License Report</h1>
              <table>
                  <tr>
                      <th>Dependency</th>
                      <th>License</th>
                  </tr>
                  {{range .}}
                  <tr class="{{if .IsCopyleft}}copyleft{{else}}permissive{{end}}">
                      <td>{{.Name}}</td>
                      <td>{{.License}}</td>
                  </tr>
                  {{end}}
              </table>
          </body>
          </html>
          `

              tmpl, err := template.New("report").Parse(htmlTemplate)
              if err != nil {
                  return fmt.Errorf("failed to parse HTML template: %v", err)
              }

              file, err := os.Create(outputPath)
              if err != nil {
                  return fmt.Errorf("failed to create HTML file: %v", err)
              }
              defer file.Close()

              err = tmpl.Execute(file, results)
              if err != nil {
                  return fmt.Errorf("failed to execute HTML template: %v", err)
              }

              return nil
          }
          EOF

          # Run the Go tool
          go run main.go

      # Step 6: Upload the HTML report as an artifact
      - name: Upload HTML Report
        uses: actions/upload-artifact@v4
        with:
          name: license-report
          path: report.html
